import Arbitrary from '../../../src/check/arbitrary/definition/Arbitrary';
import Shrinkable from '../../../src/check/arbitrary/definition/Shrinkable';
import MutableRandomGenerator from '../../../src/random/generator/MutableRandomGenerator';

/**
 * CounterArbitrary
 * 
 * each call to generate increase the produced value
 * beware that this one is not pure (::generate)
 */
class CounterArbitrary extends Arbitrary<number> {
    public generatedValues: number[] = [];
    constructor(private value: number) {
        super();
    }
    generate(rng: MutableRandomGenerator): Shrinkable<number> {
        const last = (this.value++) | 0; // keep it in integer range
        this.generatedValues.push(last);
        return new Shrinkable(last);
    }
}

/**
 * ForwardArbitrary
 * 
 * simply forward the values generated by the MutableRandomGenerator
 */
class ForwardArbitrary extends Arbitrary<number> {
    constructor() {
        super();
    }
    generate(rng: MutableRandomGenerator): Shrinkable<number> {
        return new Shrinkable(rng.next()[0]);
    }
}

/**
 * SingleUseArbitrary
 * 
 * only one call to generate is allowed
 * other calls will throw an exception
 */
class SingleUseArbitrary<T> extends Arbitrary<T> {
    called_once: boolean = false;
    constructor(public id: T) {
        super();
    }
    generate(mrng: MutableRandomGenerator) {
        if (this.called_once) {
            throw "Arbitrary has already been called once";
        }
        this.called_once = true;
        return new Shrinkable(this.id);
    }
}

export { CounterArbitrary, ForwardArbitrary, SingleUseArbitrary };